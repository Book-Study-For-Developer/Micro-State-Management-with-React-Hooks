## 06. 전역 상태 관리 라이브러리 소개

### 전역 상태 관리 문제 해결하기

> [!IMPORTANT]
> 리액트는 컴포넌트라는 개념을 중심으로 설계됐고, 컴포넌트 모델에서는 모든 것이 재사용 가능한 것으로 여겨진다.

🔫 그런데, 지금까지 다룬 전역 상태는 `컴포넌트 외부`에 존재한다. 컴포넌트에 대한 추가적인 의존성이 필요하기 때문에 가능하면 전역 상태를 피하는 것이 좋지만 전역 상태를 사용하는 것은 매우 편리하고 생산성을 높일 수 있다.

그렇기 때문에, 전역 상태를 설계할 때는 두 가지 문제점을 꼭 짚어야 한다고 말한다.

1. 전역 상태를 사용하는 컴포넌트는 모든 값이 필요하지 않은 경우가 있는데, 사실 전역 상태가 바뀌면 리렌더링이 일어나서 변경된 값이 컴포넌트랑 관련이 없어도 바뀐다.
2. 전역 상태는 여러 값을 가질 수 있기 때문에, 일부는 중첩된 객체일 수 있다. 이럴 때 직접 값을 변경하면 변경 사항을 감지하고 리액트 컴포넌트를 리렌더링할 방법이 없어서 좋지 않다.

```tsx
// 전역 상태 변경을 감지하기 위해서 전역 상태를 변경하는 함수
const createContainer = () => {
  let state = { a; 1, b: 2 };
  const getState = () => state;
  const setState = (...) => { ... };
  return { getState, setState };
};

const globalContainer = createContainer();
globalContainer.setState(...);
```

### 데이터 중심 접근 방식과 컴포넌트 중심 접근 방식 사용하기

#### 데이터 중심 접근 방식 이해하기

어플리케이션 설계 시에 데이터 모델은 싱글톤으로 가질 수 있고, 처리할 데이터가 이미 있을 수도 있다. 이 경우 컴포넌트를 정의하고 데이터와 컴포넌트를 연결한다.

이러한 데이터 중심 접근 방식을 사용하는 전역 상태 라이브러리는 모듈 상태를 생성하고 모듈 상태를 리액트 컴포넌트에 연결하는 API를 제공한다. 모듈 상태는 보통 상태 변수에 접근하고 갱신하는 메서드를 가진 store 객체로 감싼다.

#### 컴포넌트 중심 접근 방식 이해하기

컴포넌트 중심 접근 방식에서는 컴포넌트 생명 주기 내에서 전역 상태를 유지하는 것이 더 적합하다. 의존하는 컴포넌트가 모두 마운트 해제되면 전역 상태도 함께 사라지기 때문이다. 이를 활용하면 독립된 두 개 이상의 전역 상태를 둘 수 있는데, 각 전역 상태는 서로 다른 컴포넌트 하위 트리에 존재하기 때문이다.

이러한 컴포넌트 중심 접근 방식을 사용하는(아마 책의 이 부분에서 오타가 있는 것 같습니다...) 전역 상태 라이브러리는 팩토리 함수를 제공하고, 이러한 팩토리 함수에서는 리액트 컴포넌트에서 사용할 전역 상태를 초기화하는 함수를 생성한다.

### 두 접근 방식의 예외

1. 모듈 상태는 대체로 싱글톤으로 구현되지만 하위 트리에 대해 여러 모듈 상태를 만들 수도 있다. 심지어 모듈 상태의 생명 주기를 제어할 수도 있다.
2. 공급자 컴포넌트를 최상위에 두고 트리가 하나만 있으면 사실상 싱글톤이다.

### 리렌더링 최적화

전역 상태에서 리렌더링을 피하는 것은 정말 중요한 문제다. 상태의 직접 변경을 막기 위해 다음과 같은 방법을 선택할 수 있다.

#### 선택자 함수 사용

선택자 함수는 상태를 받아 상태의 일부를 반환한다.

```tsx
// 이 컴포넌트는 state.b.c
const Component = () => {
  const value = useSelector((state) => state.b.c);
  return <>{value}</>;
};
```

useSelector는 상태가 변경될 때마다 선택자 함수의 결과를 비교하는 데 사용한다.

#### 속성 접근 감지

속성 접근을 감지하고 감지한 정보를 렌더링 최적화에 사용할 수 있는 상태 사용 추적(state usage tracking)이 있다.

```tsx
// 상태 사용 추적 기능이 있는 useTrackedState 훅 사용
const Component = () => {
  const trackedState = useTrackedState();
  return <p>{trackedState.b.c}</p>;
};
```

이 훅을 통해 trackedState가 .b.c 속성에 접근한지 알 수 있고 .b.c 속성 값이 변경될 때만 useTrackedState가 리렌더링을 발생시킨다. useSelector가 수동 렌더링 최적화 방식이라면 useTrackedState는 자동 렌더링 최적화다.

useTrackedState를 구현하려면 상태 객체에 대한 속성 접근을 확인하기 위한 프록시 객체가 필요하다.(👉 Vue.js에서 상태 변화를 감지하는 방법으로 알고 있다!)

#### useSelector와 useTrackedState의 차이점

그렇다고 해서, 자동 렌더링 최적화가 완벽하게 작동하는 것은 아니다.

```tsx
const Component = () => {
  const isSmall = useSelector((state) => state.a < 10);
  return <>{isSmall ? "small" : "big"}</>;
};

const Component = () => {
  const isSmall = useTrackedState().a < 10;
  return <>{isSmall ? "small" : "big"}</>;
};
```

기능 면에서 useTrackedState를 사용한 컴포넌트는 잘 동작하지만 state.a가 변경될 때마다 리렌더링된다. 반대로 useSelector를 사용하면 isSmall이 변경될 때만 리렌더링되므로 useTracked보다 더 최적화됐다.

#### 아톰 사용

아톰은 리렌더링을 발생시키는 최소 상태 단위다. 전체 전역 상태를 구독해서 리렌더링을 피하는 대신 아톰을 사용하면 좀 더 세분화해서 구독할 수 있다.
