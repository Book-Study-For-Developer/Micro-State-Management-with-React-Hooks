### 전역 상태 관리 문제 해결하기

#### 전역 상태 설계 시 두 가지 문제점

- 전역 상태를 읽는 방법
  - 전역 상태가 바뀌면 리렌더링이 발생하는데, 변경된 값이 컴포넌트와 관련 없는 경우에도 리렌더링이 발생
- 전역 상태에 값을 넣거나 갱신하는 방법
  - 전역 상태가 중첩된 객체일 경우, 개발자가 직접 값을 변경하는 것은 좋은 않은 방법
  - mutate하게 된다면, 변경 사항을 감지하고 리액트 컴포넌트를 리렌더링할 방법이 없음

> 따라서 전역 상태 변경을 감지하기 위해 전역 상태를 변경하는 함수를 제공해야 한다.

- 직접 변경을 할 수 없도록 클로저로 변수를 숨기기도 함

```tsx
const createContainer = () => {
  let state = { a: 1, b: 2 }
  const getState = () => state
  const setState = nextState => {
    state = typeof nextState === 'function' ? nextState(state) : nextState
  }
  return { getState, setState } // state 숨김
}
```

### 데이터 중심 접근 방식과 컴포넌트 중심 접근 방식 사용하기

#### 데이터 중심 접근 방식

- 데이터 중심 접근 방식의 경우 모듈 상태가 리액트 외부에 있기 때문에 모듈 상태를 사용하는 것이 적합
- 모듈 상태는 리액트가 렌더링을 시작하기 전이나 모든 리액트 컴포넌트가 마운트 해제된 후에도 존재할 수 있음
  - 즉, 리액트 컴포넌트 생명 주기 내에서 동작하는 게 아니기 때문에 사용 시 리액트 컴포넌트에 연결이 필요
  - 기본적으로 데이터 중심 접근 방식을 사용하는 전역 상태 라이브러리는 모듈 상태를 생성하고 모듈 상태를 리액트 컴포넌트에 연결하는 API 제공
- 이때, 모듈 상태는 보통 상태 변수에 접근하고 갱신하는 메서드를 가진 store 객체로 감싸서 제공
- redux, zustand 등이 해당

#### 컴포넌트 중심 접근 방식

- 데이터 모델이 컴포넌트에 강한 의존성을 지님
- 컴포넌트 중심 접근 방식의 경우 컴포넌트 생명 주기 내에서 전역 상태를 유지하는 것이 적합
- 의존하는 컴포넌트가 모두 마운트 해제되면 전역 상태도 함께 사라짐
- recoil, jotai 등이 해당

### 리렌더링 최적화

- 리렌더링 최적화의 핵심은 컴포넌트에서 state의 어느 부분이 사용될지 지정하는 것 → **필요한 것만 지정한다!**
- state의 **일부분**을 지정하는 접근 방식 → 선택자 함수, 속성 접근 감지, 아톰

#### 선택자 함수 사용

- 선택자 함수: 상태를 받아 상태의 일부 반환
- 상태를 명시적으로 지정하는 방법 → **수동 최적화**

```tsx
const Component = () => {
  const value = useSelector(state => state.b.c)
  return <>{value}</>
}
```

- 상태가 변경될 때마다 선택자 함수의 결과를 비교하는 데 사용
- 선택자 함수는 매우 유연해서 상태의 일부뿐만 아니라 파생된 값도 반환할 수 있음
- 선택자 함수가 파생된 객체 값을 반환하는 경우, **메모이제이션**을 사용해 동일한 객체를 반환해야 함

#### 속성 접근 금지

- 속성 접근을 감지하고 감지한 정보를 렌더링에 사용할 수 있는 상태 사용 추적(state usage tracking) → **자동 최적화**

```tsx
const Component = () => {
  const trackedState = useTrackedState()
  return (
    <>
      <p>{trackedState.b.c}</p>
      <p>{trackedState.e.g}</p>
    </>
  )
}
```

- useTrackedState가 있다고 가정했을 때, trackedState가 `.b.c` 속성을 자동으로 감지
- 상태 객체에 대한 속성 접근 확인을 위해 프락시(proxy)가 필요

#### 아톰 사용

- 아톰: 리렌더링을 발생시키는 데 사용되는 최소 상태 단위
- 전체 전역 상태를 구독해서 리렌더링을 피하는 대신 아톰을 사용하면 좀 더 세분화해서 구독이 가능
- 수동 최적화와 자동 최적화의 중간 정도 → 아톰과 파생 값 정의(수동) + 의존성 추적(자동)

```tsx
const globalState = {
  a: atom(1),
  b: atom(b),
  c: atom(c),
}

const Component = () => {
  const value = useAtom(globalState.a)
  return <>{value}</>
}
```
